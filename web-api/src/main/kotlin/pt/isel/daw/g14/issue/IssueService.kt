package pt.isel.daw.g14.issue

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import pt.isel.daw.g14.common.*
import pt.isel.daw.g14.common.model.ListOfItemsWrapper
import pt.isel.daw.g14.common.model.Labels
import pt.isel.daw.g14.common.model.ProjectsState
import pt.isel.daw.g14.common.model.State
import pt.isel.daw.g14.project.*
import java.net.URI
import java.util.*
import java.util.function.Consumer


// Non null asserted calls are used on all functions that use getId(), the id will never be null because it is auto
// generated by jpa so this shouldn't be a problem
// We use this because we don't want to give an id when creating an issue on the database therefore it is a nullable field


@Service
class IssueService(
        @Autowired private val issueRepository: IssueRepository,
        @Autowired private val projectRepository: ProjectRepository) {

    fun getAllIssues(): List<SirenEntity<IssueOutputModel>> {
        val issues = issueRepository.findAll()

        if (issues.any()) {

            return issues.map {
                IssueOutputModel(it)
                        .toSirenObject(URI(getSpecificIssuePath(it.id!!)), listOf(
                                CREATE_ISSUE_ACTION,
                                getIssuesFromProjectAction(it.project.name),
                                getIssueDeletionAction(it.id!!),
                                getIssueDisplayAction(it.id!!),
                                getIssueCommentCreationAction(it.id!!),
                                getIssueLabelCreationAction(it.id!!),
                                getIssuesStateEditionAction(it.id!!)
                        ))
            }
        }

        return listOf(IssueOutputModel(IssueInputModel(
                null,
                ProjectInputModel("", "", ListOfItemsWrapper(mutableListOf()), ProjectsState()),
                "",
                "",
                Labels(),
                State(),
                ListOfItemsWrapper(mutableListOf()),
                Date(),
                Date()
        ))
                .toSirenObject(URI(ISSUE_PATH), listOf(
                        CREATE_ISSUE_ACTION
                )))
    }

    fun createIssue(issue: Issue): SirenEntity<IssueOutputModel> {

        try {

            var issueInputModel: IssueInputModel? = null

            manageSpecificProjectAndThrowIfNotFound(
                    issue.projectsName,
                    Consumer {
                        // check if user created issue has a possible state for this project
                        if (it.projectsState
                                        .possibleStates
                                        .any { project -> project.presentState == issue.state.presentState }
                        ) {

                            if (issue.labels.checkIfLabelIsExistent()) {

                            // Turn the fake issue into a real issue
                            // This was made to not obligate the client to send a full project on the request body
                            // instead the client sends only the project's name and we handle the rest with the fake issue
                            // This solution made us use the non null asserted call on the id's explained on the top of the file
                            issueInputModel = issueRepository.save(
                                    IssueInputModel(
                                            project = it,
                                            name = issue.name,
                                            description = issue.description,
                                            labels = issue.labels,
                                            state = issue.state,
                                            comments = issue.comments
                                    ))
                            return@Consumer

                            } else {
                                throw IssueLabelNonExistent()
                            }
                        } else
                        throw IssueStateNotAllowed()
                    },
                    projectRepository
            )

            return IssueOutputModel(issueInputModel)
                    .toSirenObject(URI(ISSUE_PATH), listOf(
                            getIssuesFromProjectAction(issueInputModel!!.project.name),
                            getIssueDeletionAction(issueInputModel!!.id!!),
                            getIssueDisplayAction(issueInputModel!!.id!!),
                            getIssueCommentCreationAction(issueInputModel!!.id!!),
                            getIssueLabelCreationAction(issueInputModel!!.id!!),
                            getIssuesStateEditionAction(issueInputModel!!.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }

    fun deleteIssue(issueId: Int): SirenEntity<IssueOutputModel> {

        try {

            val issue = manageSpecificIssueAndThrowIfNotFound(
                    issueId,
                    Consumer { issueRepository.deleteById(issueId) }
            )

            return IssueOutputModel(issue)
                    .toSirenObject(URI(getSpecificIssuePath(issueId)), listOf(
                            CREATE_ISSUE_ACTION,
                            getIssuesFromProjectAction(issue.project.name),
                            getIssueDisplayAction(issue.id!!),
                            getIssueCommentCreationAction(issue.id!!),
                            getIssueLabelCreationAction(issue.id!!),
                            getIssuesStateEditionAction(issue.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }

    fun getSpecificProjectsIssues(projectsName: String): List<SirenEntity<IssueOutputModel>> =
            issueRepository
                    .findAll()
                    .filter { it.project.name == projectsName }
                    .map { IssueOutputModel(it)
                            .toSirenObject(URI(getSpecificIssuePath(it.id!!)), listOf(
                                    CREATE_ISSUE_ACTION,
                                    getIssueDisplayAction(it.id!!),
                                    getIssueDeletionAction(it.id!!),
                                    getIssueCommentCreationAction(it.id!!),
                                    getIssueLabelCreationAction(it.id!!),
                                    getIssuesStateEditionAction(it.id!!)
                            )) }


    fun getIssue(issueId: Int): SirenEntity<IssueOutputModel> {

        try {

            val issue = manageSpecificIssueAndThrowIfNotFound(
                    issueId,
                    Consumer {  }
            )

            return IssueOutputModel(issue)
                    .toSirenObject(URI(getSpecificIssuePath(issueId)), listOf(
                            CREATE_ISSUE_ACTION,
                            getIssuesFromProjectAction(issue.project.name),
                            getIssueDeletionAction(issue.id!!),
                            getIssueCommentCreationAction(issue.id!!),
                            getIssueLabelCreationAction(issue.id!!),
                            getIssuesStateEditionAction(issue.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }



    fun addComment(issueId: Int, newListOfItemsWrapper: ListOfItemsWrapper): Any {

        try {

            val issue = manageSpecificIssueAndThrowIfNotFound(
                    issueId,
                    Consumer<IssueInputModel> { issue ->

                        if (issue.comments.addComments(issue.state, newListOfItemsWrapper)) {
                            issueRepository.updateIssuesComments(issueId, issue.comments)
                        } else {
                            throw CommentOnArchivedIssue()
                        }
                    }

            )

            return IssueOutputModel(issue)
                    .toSirenObject(URI(getIssuesCommentPath(issueId)), listOf(
                            CREATE_ISSUE_ACTION,
                            getIssuesFromProjectAction(issue.project.name),
                            getIssueDeletionAction(issue.id!!),
                            getIssueDisplayAction(issue.id!!),
                            getIssueLabelCreationAction(issue.id!!),
                            getIssuesStateEditionAction(issue.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }

    fun addLabel(issueId: Int, newLabels: Labels): Any {


        try {

            val issue = manageSpecificIssueAndThrowIfNotFound(
                    issueId,
                    Consumer<IssueInputModel> {
                        issue ->
                        if (issue.labels.changePresentLabel(newLabels)) {
                            issueRepository.updateIssuesLabels(issueId, newLabels)
                        } else {
                            throw LabelNonExistent()
                        }
                    }
            )

            return IssueOutputModel(issue)
                    .toSirenObject(URI(getIssuesLabelPath(issueId)), listOf(
                            CREATE_ISSUE_ACTION,
                            getIssuesFromProjectAction(issue.project.name),
                            getIssueDeletionAction(issue.id!!),
                            getIssueDisplayAction(issue.id!!),
                            getIssueCommentCreationAction(issue.id!!),
                            getIssuesStateEditionAction(issue.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }

    fun editState(issueId: Int, newState: State): Any {

        try {

            val issue = manageSpecificIssueAndThrowIfNotFound(
                    issueId,
                    Consumer<IssueInputModel> {
                        issue ->
                        manageSpecificProjectAndThrowIfNotFound(
                                issue.project.name,
                                Consumer {
                                    if (it.projectsState.isStateChangeAllowed(issue.state, newState)) {
                                        issue.state = newState
                                        issueRepository.updateIssuesState(issueId, newState)

                                    } else {
                                        throw TransitionNotAllowed()
                                    }
                                },
                                projectRepository)
                    })

            return IssueOutputModel(issue)
                    .toSirenObject(URI(getIssueStatePath(issueId)), listOf(
                            CREATE_ISSUE_ACTION,
                            getIssuesFromProjectAction(issue.project.name),
                            getIssueDeletionAction(issue.id!!),
                            getIssueDisplayAction(issue.id!!),
                            getIssueCommentCreationAction(issue.id!!),
                            getIssueLabelCreationAction(issue.id!!)
                    ))

        } catch (e: Exception) {
            throw e
        }
    }


    private fun manageSpecificIssueAndThrowIfNotFound(issueId: Int, ifFound: Consumer<IssueInputModel>): IssueInputModel {

        var presentIssue: IssueInputModel? = null

        issueRepository
                .findById(issueId)
                .ifPresentOrElse(
                        { issue ->
                            run {
                                presentIssue = issue
                                ifFound.accept(issue)
                            }
                        },
                        { throw IssueNotFound() }
                )

        return presentIssue ?: throw IssueNotFound()
    }



}